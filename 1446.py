import sys
import heapq

'''
핵심!
if dist[u] + w < dist[v]:
    dist[v] = dist[u] + w   # v까지 더 싼 경로를 발견했으니 갱신

즉, “u를 거쳐서 v로 가는 길이 지금까지 알던 v까지의 길보다 싸면, 그걸로 바꿔!”가 relaxation.

작은 예시로 보는 다익스트라

고속도로 길이 `D = 10`.
기본 도로는 1km 이동할 때마다 비용 1이라서, 0→1→2→…→10 이면 비용 10이야.
지름길이 두 개 있다고 하자:

* 지름길 A: `0 → 5` (비용 3)
* 지름길 B: `5 → 10` (비용 3)

이 경우의 **최단 답은 0→5(3) →10(3) = 총 6** 이겠지?

다익스트라 진행을 간단히 추적:

초기화

* `dist[0]=0`, 나머지는 ∞
* 우선순위 큐 pq ← `(0, 0)`

1. 팝: `(0, 0)`

* 0에서 나가는 간선들 완화:

  * 기본 도로: `0→1 (1)` → `dist[1] = min(∞, 0+1)=1`  → pq에 `(1,1)` 푸시
  * 지름길 A: `0→5 (3)` → `dist[5] = min(∞, 0+3)=3` → pq에 `(3,5)` 푸시
    현재: `dist = [0, 1, ∞, ∞, ∞, 3, ∞, ∞, ∞, ∞, ∞]`, pq = `[(1,1), (3,5)]`

2. 팝: **가장 짧은 것** `(1, 1)`

* 1에서 나가는 간선 완화:

  * `1→2 (1)` → `dist[2] = min(∞, 1+1)=2` → pq에 `(2,2)`
    현재: `dist[2]=2`, pq = `[(2,2), (3,5)]`

3. 팝: `(2, 2)`

* 2에서:

  * `2→3 (1)` → `dist[3] = 3` → pq에 `(3,3)`
    현재: pq = `[(3,3), (3,5)]`

4. 팝: `(3, 3)`

* 3에서:

  * `3→4 (1)` → `dist[4] = 4` → pq에 `(4,4)`
    현재: pq = `[(3,5), (4,4)]`

5. 팝: **같이 3인데** 우연히 `(3,5)`가 먼저 나왔다고 하자 (순서는 구현 세부차이).

* 5에서:

  * 기본 도로: `5→6 (1)` → `dist[6] = min(∞, 3+1)=4` → pq에 `(4,6)`
  * 지름길 B: `5→10 (3)` → `dist[10] = min(∞, 3+3)=6` → pq에 `(6,10)`
    현재: `dist[10]=6`을 벌써 얻음! pq = `[(4,4), (4,6), (6,10)]`

6. 그 다음 팝들은 `(4,4)`, `(4,6)` … 이런 식으로 계속 진행하지만,

   * 예를 들어 `6`에서 직선으로 10까지 가면 비용이 `3(0→5) + 1(5→6) + (6→7→8→9→10의 4)` = 8이라서
     이미 알고 있는 `dist[10]=6`보다 **더 비싸므로** 10의 값은 **변경되지 않아**.

결국 최종 `dist[10] = 6`으로 확정된다.

**포인트**

* 우선순위 큐에서 항상 “지금까지 발견된 경로 중 가장 짧은 거리 정점”을 먼저 꺼내어(=신뢰 가능한 최단 후보),
* 그 정점에서 뻗어나가는 간선들을 완화하면서 “이웃 정점까지 더 싼 경로가 발견되면 갱신”하는 과정을 반복.
* **가중치가 모두 음이 아닌 경우**, 한 번 팝(확정)된 정점의 거리는 더 이상 줄어들 수 없기 때문에 이 방식으로 전체가 최단이 된다.

'''

input = sys.stdin.readline
INF = float("inf")

# N: 지름길 개수(<=12), D: 고속도로 길이(<=10000)
N, D = map(int, input().split())

# 그래프: 0~D 각 위치를 정점으로 보고 인접 리스트 구성
# graph[u] = [(v, w), ...] : u -> v 가중치 w
graph = [[] for _ in range(D + 1)]

# 1) 기본 도로 간선: i -> i+1 (가중치 1)
#    고속도로에서 1km 전진하는 비용은 항상 1
for i in range(D):
    graph[i].append((i + 1, 1))

# 2) 지름길 간선 추가: start -> end (가중치 length)
#    단, 도착점 D를 넘어가는 지름길은 무시(end > D),
#    시작점이 D를 넘어도 무시(start > D).
for _ in range(N):
    start, end, length = map(int, input().split())

    # 문제에서 start < end 보장. end <= D 인 것만 유효.
    # (length가 end-start보다 크더라도 다익스트라가 자동으로 안 쓰게 됩니다.)
    if start <= D and end <= D:
        graph[start].append((end, length))

# 다익스트라 준비
dist = [INF] * (D + 1)
dist[0] = 0  # 시작점(0)의 최단거리 = 0

# 우선순위 큐: (현재까지 거리, 정점)
pq = []
heapq.heappush(pq, (0, 0))

# 다익스트라 실행
while pq:
    cur_dist, u = heapq.heappop(pq)

    # 이미 더 짧은 경로를 알고 있다면 스킵 (중복 팝 최적화)
    if cur_dist > dist[u]:
        continue

    # u에서 나가는 모든 간선을 완화(relax)
    for v, w in graph[u]:
        nd = dist[u] + w
        if nd < dist[v]:
            dist[v] = nd
            heapq.heappush(pq, (nd, v))

# 0에서 D까지의 최단거리 출력
print(dist[D])
