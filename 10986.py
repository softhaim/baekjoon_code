'''
수 N개 A1, A2, ..., AN이 주어진다. 이때, 연속된 부분 구간의 합이 M으로 나누어 떨어지는 구간의 개수를 구하는 프로그램을 작성하시오.

즉, Ai + ... + Aj (i ≤ j) 의 합이 M으로 나누어 떨어지는 (i, j) 쌍의 개수를 구해야 한다.

'''

'''
이게 0 mod M 이려면:

(S[j]−S[i−1])%M=0

모듈러 성질 때문에:

S[j]%M=S[i−1]%M

✅ 결론:
**“구간합이 M으로 나누어 떨어지는 구간”**은
**“누적합 나머지가 같은 두 위치를 고르는 것”**과 똑같다.

예를 들어

M = 3

수열: [1, 2, 3, 1, 2]

누적합 S를 구하면:


S1 = 1

S2 = 3

S3 = 6

S4 = 7

S5 = 9

이제 각각을 3으로 나눈 나머지:


S1 % 3 = 1

S2 % 3 = 0

S3 % 3 = 0

S4 % 3 = 1

S5 % 3 = 0

나머지 배열로 쓰면:

[0, 1, 0, 0, 1, 0]

“나머지가 같은 두 개를 고르면 구간 하나”

왜냐면, 예를 들어 S2와 S0가 둘 다 나머지 0이면:

S3 - S2 = (A3)

이 값은 3으로 나누어 떨어짐

실제로:

A3 = 3 

또 S3(0)과 S2(0)를 고르면:

S3 - S2 = A3 = 3 (3으로 나누어 떨어짐)

즉,
✅ 나머지가 같은 누적합 위치 2개를 고르면 그 사이 구간합은 무조건 0 mod M.
나머지별로 몇 번 나왔는지 세어보자:

나머지 0: 4번 (S0, S2, S3, S5)

나머지 1: 2번 (S1, S4)

나머지 2: 0번

나머지 0이 4번이면,
거기서 2개 고르는 방법 수 = 4C2 = 4*3/2 = 6
→ 구간 6개가 “3으로 나누어 떨어짐”

나머지 1이 2번이면:
2C2 = 1

총 7개.

이게

c * (c - 1) // 2

여기서 주의점으로는 S[2] 같이 처음부터 해당 지점까지의 누적합은 S[2] - S[0] = A1 + A2 가 될 것임. 
여기서 S[0]는 아무것도 없는 공집합으로 이에 대한 정의가 있어야만 S[0]를 선택하여 처음부터 합한 경우의 수를 확인 가능함. 
그래서 mod[0] = 1 가 초기화 되어야함. 공집합을 M으로 나눈 나머지 값. 
'''

import sys

input = sys.stdin.readline

N, M = map(int, input().split())

numbers = list(map(int, input().split()))

mod_value = [0]*M # 나머지 값들 저장해둘 배열
mod_value[0] = 1
sum_value = 0

# 위에서 말한대로 구간합이 나누어 떨어지는 것을 구하는 것은 누적합을 나눈 나머지 값이 같은 것의 위치를 고르는 것과 같음! 
for x in numbers:
    sum_value = sum_value + x
    mod_value[sum_value%M] += 1

# 나머지 값들 개수 구했으니까 이제 여기서 조합을 찾으면 됨. 나머지개수_C_2 임.
ans = 0
for val in mod_value:
    ans +=  (val * (val -1)) // 2
print(ans)