'''
45656이란 수를 보자.

이 수는 인접한 모든 자리의 차이가 1이다. 이런 수를 계단 수라고 한다.

N이 주어질 때, 길이가 N인 계단 수가 총 몇 개 있는지 구해보자. 0으로 시작하는 수는 계단수가 아니다.

입력
첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 100보다 작거나 같은 자연수이다.

출력
첫째 줄에 정답을 1,000,000,000으로 나눈 나머지를 출력한다.
1 입력 -> 9
2 입력 -> 17

알고리즘을 한번 생각해보자. 
1일때, 길이가 1인 계단 수는 0 제외 1,2,3,...9 까지 9개이다. 
2일때 길이가 2인 계단 수는 
12, 23, 34, 45, ..., 89 8개로 10-n 개와
21, 32, 43, ... ,98 로 내림차순 10-n 개 있을 것.
01은 “첫 자리가 0”이라서 불가지만, 10은 가능
총 17 개

3일때 길이 3인 계단수?
123, 234, ... 789 로 n-1 개일때 경우에서 뒤에 하나 더붙인것과 개수 같음.
321, 432, ... 987 로 n-1 개일때 경우에서 반대 경우 개수랑 같음 
121, 232, 343, .. ,898 로 올라갔다 내려갔다 하는것이 n-1 일때 상황에서 하나 더 하는거

애초에 n 개일때 처음 가능한 시작의 경우의 수 => 9개 
그 다음 수로 가능한것 하나 더하거나 빼거나 => 9의 경우 10 은 안되니까 +(9-1) 개
그 다음 수로 가능한것(3번째 자리 수) 이 수에서 또 하나 더하거나 빼거나 마지막 수 9거나 0인 경우 제외 하면 +(17-2) => 32개


앞에 오는 숫자 = 0 )
dp[자리 수][0] = dp[자리 수 - 1][1]
※ dp[1][0] = 0이기 때문에 어차피 결과엔 영향을 미치지 않는다.
ex) 0, 01, 012 -> 안 셈!

앞에 오는 숫자 = 1~8 )
dp[자리 수][앞에 오는 숫자] = dp[자리 수 - 1][앞에 오는 숫자 -1] + dp[자리 수 - 1][앞에 오는 숫자 + 1]
dp[n][i] = dp[n-1][i-1] + dp[n-1][i+1]

앞에 오는 숫자 =9 )
dp[자리 수][9] = dp[자리 수 - 1][8]

'''

import sys

input = sys.stdin.readline

N = int(input())

dp = [[0] * 10 for i in range(N+1)]

# 자리 수 1 대해서 가능한 경우는 어차피 자기 자신 뿐임.
for i in range(1,10): 
    dp[1][i] = 1

for i in range(2, N+1):
    for j in range(10):
        if j == 0:
            dp[i][j] = dp[i-1][j+1]
        elif j == 9:
            dp[i][j] = dp[i-1][j-1]
        else: # 마지막 숫자 1~8 경우
            dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1]


print(sum(dp[N])%1000000000)