'''
포도주 잔을 선택하면 그 잔에 들어있는 포도주는 모두 마셔야 하고, 마신 후에는 원래 위치에 다시 놓아야 한다.
연속으로 놓여 있는 3잔을 모두 마실 수는 없다.

효주는 될 수 있는 대로 많은 양의 포도주를 맛보기 위해서 어떤 포도주 잔을 선택해야 할지 고민하고 있다. 
1부터 n까지의 번호가 붙어 있는 n개의 포도주 잔이 순서대로 테이블 위에 놓여 있고, 각 포도주 잔에 들어있는 포도주의 양이 주어졌을 때, 효주를 도와 가장 많은 양의 포도주를 마실 수 있도록 하는 프로그램을 작성하시오. 

예를 들어 6개의 포도주 잔이 있고, 각각의 잔에 순서대로 6, 10, 13, 9, 8, 1 만큼의 포도주가 들어 있을 때, 
첫 번째, 두 번째, 네 번째, 다섯 번째 포도주 잔을 선택하면 총 포도주 양이 33으로 최대로 마실 수 있다.

예전에 풀었던 1,2칸씩만 올라갈 수 있고 연속 3개는 안되는 계단 문제와 비슷. 

결국 이 문제는 dp 로
1 은 6 그대로
2 는 1-2, 혹은 2 로 올 수 있고 이때의 최대는 6+10 16 될 것.
3 은 1-3, 2-3 둘 중 하나로 올 수 있고 이때의 최대는 6+13, 10+13 으로 max는 23.
4는 1-2-4, 2-4, 1-3-4 로만 가능이고, 1-2-4, 2-4가 2의 max에 따라서 결정되며 2-4 랑 같음. 2-4, 1-3-4 둘 중 max 로 16+9 = 25, 6+13+9=28 로 28
5 도 3-5 와 2-4-5 중 비교 하면 됨.

패턴은 결국 max(dp[i-2] + 현재값, dp[i-1] 입력값[i-3] + 현재값) 임.

*** 틀린 핵심 내용 ***
계단 오르기는 무조건 마지막 계단을 밟아야 한다는 조건이 있었다.

하지만 포도주 시식 문제는 무조건 마지막 포도주를 마시지 않아도 됨.
그래서 dp[i-1]이 더 크면 안마시고 지나친 경우로도 계산 해줘야 함.

예를 들어 5 에서 1-3-4 가 x이고 1-3-5 혹은 2-4-5가 저 x 보다 낮은경우에는 그냥 1-3-4-(5)하고 가는게 가능하다는 것.
'''

import sys 

input = sys.stdin.readline

N = int(input())
grape_amount_list = [0]
for i in range(N):
    grape_amount_list.append(int(input()))

dp = [0]*(N+1)

dp[1] = grape_amount_list[1]

for i in range(2,N+1):
    if i==2:
        dp[i] = max(dp[1] + grape_amount_list[i], grape_amount_list[i]) # dp[1] 이 음수가 아닌 이상 어차피 합하면 되지만 혹시 모르니까 max로 구함.
    elif i==3:
        dp[i] = max(grape_amount_list[1] + grape_amount_list[i], grape_amount_list[2] + grape_amount_list[i], dp[2])
    else: # i >= 4 인 경우
        dp[i] = max(dp[i-2] + grape_amount_list[i], dp[i-3]+grape_amount_list[i-1]+grape_amount_list[i], dp[i-1])

print(max(dp))